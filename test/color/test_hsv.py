import pytest

import kornia
from kornia.constants import pi
import kornia.testing as utils  # test utils
from test.common import device

import math

import torch
from torch.autograd import gradcheck
from torch.testing import assert_allclose


class TestRgbToHsv:

    def test_rgb_to_hsv(self, device):

        data = torch.tensor([[[0.3944633, 0.8597369, 0.1670904, 0.2825457, 0.0953912],
                              [0.1251704, 0.8020709, 0.8933256, 0.9170977, 0.1497008],
                              [0.2711633, 0.1111478, 0.0783281, 0.2771807, 0.5487481],
                              [0.0086008, 0.8288748, 0.9647092, 0.8922020, 0.7614344],
                              [0.2898048, 0.1282895, 0.7621747, 0.5657831, 0.9918593]],

                             [[0.5414237, 0.9962701, 0.8947155, 0.5900949, 0.9483274],
                              [0.0468036, 0.3933847, 0.8046577, 0.3640994, 0.0632100],
                              [0.6171775, 0.8624780, 0.4126036, 0.7600935, 0.7279997],
                              [0.4237089, 0.5365476, 0.5591233, 0.1523191, 0.1382165],
                              [0.8932794, 0.8517839, 0.7152701, 0.8983801, 0.5905426]],

                             [[0.2869580, 0.4700376, 0.2743714, 0.8135023, 0.2229074],
                              [0.9306560, 0.3734594, 0.4566821, 0.7599275, 0.7557513],
                              [0.7415742, 0.6115875, 0.3317572, 0.0379378, 0.1315770],
                              [0.8692724, 0.0809556, 0.7767404, 0.8742208, 0.1522012],
                              [0.7708948, 0.4509611, 0.0481175, 0.2358997, 0.6900532]]])
        data = data.to(device)

        # OpenCV
        h_expected = torch.tensor([[1.6519808, 1.3188975, 2.2487938, 3.582216, 2.250954],
                                   [4.28164, 0.04868213, 0.83454597, 5.533617, 4.319574],
                                   [3.4185164, 2.7919037, 2.8883224, 1.7474692, 1.3619272],
                                   [3.6837196, 0.6378961, 5.7213116, 5.2614374, 6.259687],
                                   [2.929221, 2.5614352, 0.97840965, 1.5729411, 6.0235224]])
        h_expected = h_expected.to(device)

        s_expected = torch.tensor([[0.46999356, 0.52820253, 0.8132473, 0.65267974, 0.899411],
                                   [0.9497089, 0.534381, 0.48878422, 0.60298723, 0.9163612],
                                   [0.6343409, 0.87112963, 0.8101612, 0.9500878, 0.8192622],
                                   [0.99010557, 0.9023306, 0.42042294, 0.8292772, 0.81847864],
                                   [0.6755719, 0.8493871, 0.93686795, 0.73741645, 0.40461043]])
        s_expected = s_expected.to(device)

        v_expected = torch.tensor([[0.5414237, 0.99627006, 0.89471555, 0.81350225, 0.9483274],
                                   [0.930656, 0.80207086, 0.8933256, 0.9170977, 0.75575125],
                                   [0.74157417, 0.86247796, 0.41260356, 0.76009345, 0.7279997],
                                   [0.86927235, 0.8288748, 0.9647092, 0.892202, 0.7614344],
                                   [0.8932794, 0.8517839, 0.7621747, 0.8983801, 0.99185926]])
        v_expected = v_expected.to(device)

        f = kornia.color.RgbToHsv()
        result = f(data)

        h = result[0, :, :]
        s = result[1, :, :]
        v = result[2, :, :]

        assert_allclose(h, h_expected)
        assert_allclose(s, s_expected)
        assert_allclose(v, v_expected)

    def test_batch_rgb_to_hsv(self, device):

        data = torch.tensor([[[0.3944633, 0.8597369, 0.1670904, 0.2825457, 0.0953912],
                              [0.1251704, 0.8020709, 0.8933256, 0.9170977, 0.1497008],
                              [0.2711633, 0.1111478, 0.0783281, 0.2771807, 0.5487481],
                              [0.0086008, 0.8288748, 0.9647092, 0.8922020, 0.7614344],
                              [0.2898048, 0.1282895, 0.7621747, 0.5657831, 0.9918593]],

                             [[0.5414237, 0.9962701, 0.8947155, 0.5900949, 0.9483274],
                              [0.0468036, 0.3933847, 0.8046577, 0.3640994, 0.0632100],
                              [0.6171775, 0.8624780, 0.4126036, 0.7600935, 0.7279997],
                              [0.4237089, 0.5365476, 0.5591233, 0.1523191, 0.1382165],
                              [0.8932794, 0.8517839, 0.7152701, 0.8983801, 0.5905426]],

                             [[0.2869580, 0.4700376, 0.2743714, 0.8135023, 0.2229074],
                              [0.9306560, 0.3734594, 0.4566821, 0.7599275, 0.7557513],
                              [0.7415742, 0.6115875, 0.3317572, 0.0379378, 0.1315770],
                              [0.8692724, 0.0809556, 0.7767404, 0.8742208, 0.1522012],
                              [0.7708948, 0.4509611, 0.0481175, 0.2358997, 0.6900532]]])
        data = data.to(device)

        # OpenCV
        expected = torch.tensor([[[1.6519808, 1.3188975, 2.2487938, 3.582216, 2.250954],
                                  [4.28164, 0.04868213, 0.83454597, 5.533617, 4.319574],
                                  [3.4185164, 2.7919037, 2.8883224, 1.7474692, 1.3619272],
                                  [3.6837196, 0.6378961, 5.7213116, 5.2614374, 6.259687],
                                  [2.929221, 2.5614352, 0.97840965, 1.5729411, 6.0235224]],

                                 [[0.46999356, 0.52820253, 0.8132473, 0.65267974, 0.899411],
                                  [0.9497089, 0.534381, 0.48878422, 0.60298723, 0.9163612],
                                  [0.6343409, 0.87112963, 0.8101612, 0.9500878, 0.8192622],
                                  [0.99010557, 0.9023306, 0.42042294, 0.8292772, 0.81847864],
                                  [0.6755719, 0.8493871, 0.93686795, 0.73741645, 0.40461043]],

                                 [[0.5414237, 0.99627006, 0.89471555, 0.81350225, 0.9483274],
                                  [0.930656, 0.80207086, 0.8933256, 0.9170977, 0.75575125],
                                  [0.74157417, 0.86247796, 0.41260356, 0.76009345, 0.7279997],
                                  [0.86927235, 0.8288748, 0.9647092, 0.892202, 0.7614344],
                                  [0.8932794, 0.8517839, 0.7621747, 0.8983801, 0.99185926]]])
        expected = expected.to(device)

        # Kornia
        f = kornia.color.RgbToHsv()

        data = data.repeat(2, 1, 1, 1)  # 2x3x5x5
        expected = expected.repeat(2, 1, 1, 1)  # 2x3x5x5

        assert_allclose(f(data), expected)

    def test_nan_rgb_to_hsv(self):

        data = torch.zeros(1, 5, 5)  # 3x5x5
        data = data.repeat(3, 1, 1)  # 2x3x5x5

        # OpenCV
        expected = torch.zeros(1, 5, 5)  # 3x5x5
        expected = expected.repeat(3, 1, 1)  # 2x3x5x5

        # Kornia
        f = kornia.color.RgbToHsv()

        assert_allclose(f(data), expected)

    def test_gradcheck(self, device):

        data = torch.rand(3, 5, 5).to(device)  # 3x2x2
        data = utils.tensor_to_gradcheck_var(data)  # to var

        assert gradcheck(kornia.color.RgbToHsv(), (data,),
                         raise_exception=True)

    @pytest.mark.skip(reason="turn off all jit for a while")
    def test_jit(self, device):
        @torch.jit.script
        def op_script(data: torch.Tensor) -> torch.Tensor:

            return kornia.rgb_to_hsv(data)
            data = torch.tensor([[[[21., 22.],
                                   [22., 22.]],

                                  [[13., 14.],
                                   [14., 14.]],

                                  [[8., 8.],
                                   [8., 8.]]]])  # 3x2x2

            data = data.to(device)
            actual = op_script(data)
            expected = kornia.rgb_to_hsv(data)
            assert_allclose(actual, expected)


class TestHsvToRgb:

    def test_hsv_to_rgb(self, device):

        data = torch.tensor([[[3.5433271, 5.6390061, 1.3766849, 2.5384088, 4.6848912],
                              [5.7209363, 5.3262630, 6.2059994, 4.1164689, 2.3872600],
                              [0.6370091, 3.6186798, 5.9170871, 2.8275447, 5.4289737],
                              [0.2751994, 1.6632686, 1.0049511, 0.7046204, 1.3791083],
                              [0.7863123, 4.4852505, 4.3064494, 2.5573561, 5.9083076]],

                             [[0.5026655, 0.9453601, 0.5929778, 0.2632897, 0.4590443],
                              [0.6201433, 0.5610679, 0.9653260, 0.0830478, 0.5000827],
                              [0.6067343, 0.6422323, 0.6777940, 0.7705711, 0.6050767],
                              [0.5495264, 0.5573426, 0.4683768, 0.2268902, 0.2116482],
                              [0.6525245, 0.0022379, 0.4909980, 0.1682271, 0.6327152]],

                             [[0.8471680, 0.9302199, 0.3265766, 0.7944570, 0.7038843],
                              [0.4833369, 0.2088473, 0.1169234, 0.4966302, 0.6448684],
                              [0.2713015, 0.5893380, 0.6015301, 0.6801558, 0.2322258],
                              [0.5704236, 0.6797268, 0.4755683, 0.4811209, 0.5317836],
                              [0.3236262, 0.0999796, 0.3614958, 0.5117705, 0.8194097]]])  # 3x5x5
        data = data.to(device)

        # OpenCV
        r_expected = torch.tensor([[0.4213259, 0.93021995, 0.26564622, 0.58528465, 0.5338429],
                                   [0.48333693, 0.20884734, 0.11692339, 0.45538613, 0.32238087],
                                   [0.2713015, 0.2108461, 0.60153013, 0.15604737, 0.23222584],
                                   [0.5704236, 0.4568531, 0.4755683, 0.48112088, 0.49611038],
                                   [0.32362622, 0.09981924, 0.20394461, 0.42567685, 0.81940967]])
        r_expected = r_expected.to(device)

        g_expected = torch.tensor([[0.6838029, 0.0508271, 0.3265766, 0.794457, 0.3807702],
                                   [0.18359877, 0.0916698, 0.00405421, 0.45823452, 0.6448684],
                                   [0.20682439, 0.41690278, 0.1938166, 0.68015575, 0.0917114],
                                   [0.33933756, 0.6797268, 0.4665822, 0.44541004, 0.5317836],
                                   [0.27101707, 0.09975589, 0.18400209, 0.51177055, 0.30095676]])
        g_expected = g_expected.to(device)

        b_expected = torch.tensor([[0.84716797, 0.5917818, 0.13292392, 0.6739741, 0.7038843],
                                   [0.34453064, 0.19874583, 0.01237347, 0.4966302, 0.41256943],
                                   [0.10669357, 0.589338, 0.3363524, 0.5229789, 0.20633064],
                                   [0.25696078, 0.30088606, 0.25282317, 0.37195927, 0.41923255],
                                   [0.11245217, 0.09997964, 0.3614958, 0.46373847, 0.4865534]])
        b_expected = b_expected.to(device)

        # Kornia
        f = kornia.color.HsvToRgb()
        result = f(data)

        r = result[0, :, :]
        g = result[1, :, :]
        b = result[2, :, :]

        assert_allclose(r, r_expected)
        assert_allclose(g, g_expected)
        assert_allclose(b, b_expected)

    def test_batch_hsv_to_rgb(self, device):

        data = torch.tensor([[[3.5433271, 5.6390061, 1.3766849, 2.5384088, 4.6848912],
                              [5.7209363, 5.3262630, 6.2059994, 4.1164689, 2.3872600],
                              [0.6370091, 3.6186798, 5.9170871, 2.8275447, 5.4289737],
                              [0.2751994, 1.6632686, 1.0049511, 0.7046204, 1.3791083],
                              [0.7863123, 4.4852505, 4.3064494, 2.5573561, 5.9083076]],

                             [[0.5026655, 0.9453601, 0.5929778, 0.2632897, 0.4590443],
                              [0.6201433, 0.5610679, 0.9653260, 0.0830478, 0.5000827],
                              [0.6067343, 0.6422323, 0.6777940, 0.7705711, 0.6050767],
                              [0.5495264, 0.5573426, 0.4683768, 0.2268902, 0.2116482],
                              [0.6525245, 0.0022379, 0.4909980, 0.1682271, 0.6327152]],

                             [[0.8471680, 0.9302199, 0.3265766, 0.7944570, 0.7038843],
                              [0.4833369, 0.2088473, 0.1169234, 0.4966302, 0.6448684],
                              [0.2713015, 0.5893380, 0.6015301, 0.6801558, 0.2322258],
                              [0.5704236, 0.6797268, 0.4755683, 0.4811209, 0.5317836],
                              [0.3236262, 0.0999796, 0.3614958, 0.5117705, 0.8194097]]])  # 3x5x5
        data = data.to(device)
        data = data.repeat(2, 1, 1, 1)  # 2x3x5x5

        # OpenCV
        expected = torch.tensor([[[0.4213259, 0.93021995, 0.26564622, 0.58528465, 0.5338429],
                                  [0.48333693, 0.20884734, 0.11692339, 0.45538613, 0.32238087],
                                  [0.2713015, 0.2108461, 0.60153013, 0.15604737, 0.23222584],
                                  [0.5704236, 0.4568531, 0.4755683, 0.48112088, 0.49611038],
                                  [0.32362622, 0.09981924, 0.20394461, 0.42567685, 0.81940967]],

                                 [[0.6838029, 0.0508271, 0.3265766, 0.794457, 0.3807702],
                                  [0.18359877, 0.0916698, 0.00405421, 0.45823452, 0.6448684],
                                  [0.20682439, 0.41690278, 0.1938166, 0.68015575, 0.0917114],
                                  [0.33933756, 0.6797268, 0.4665822, 0.44541004, 0.5317836],
                                  [0.27101707, 0.09975589, 0.18400209, 0.51177055, 0.30095676]],

                                 [[0.84716797, 0.5917818, 0.13292392, 0.6739741, 0.7038843],
                                  [0.34453064, 0.19874583, 0.01237347, 0.4966302, 0.41256943],
                                  [0.10669357, 0.589338, 0.3363524, 0.5229789, 0.20633064],
                                  [0.25696078, 0.30088606, 0.25282317, 0.37195927, 0.41923255],
                                  [0.11245217, 0.09997964, 0.3614958, 0.46373847, 0.4865534]]])
        expected = expected.to(device)
        expected = expected.repeat(2, 1, 1, 1)  # 2x3x5x5

        # Kornia
        f = kornia.color.HsvToRgb()

        assert_allclose(f(data), expected)

        data[:, 0] += 2 * pi
        assert_allclose(f(data), expected)

        data[:, 0] -= 4 * pi
        assert_allclose(f(data), expected)

    def test_gradcheck(self, device):

        data = torch.rand(3, 5, 5).to(device)  # 3x5x5
        data[0] = 2 * pi * data[0]

        data = utils.tensor_to_gradcheck_var(data)  # to var

        assert gradcheck(kornia.color.HsvToRgb(), (data,),
                         raise_exception=True)

    @pytest.mark.skip(reason="turn off all jit for a while")
    def test_jit(self, device):
        @torch.jit.script
        def op_script(data: torch.Tensor) -> torch.Tensor:
            return kornia.hsv_to_rgb(data)

            data = torch.tensor([[[[21., 22.],
                                   [22., 22.]],

                                  [[13., 14.],
                                   [14., 14.]],

                                  [[8., 8.],
                                   [8., 8.]]]])  # 3x2x2

            data = data.to(device)
            actual = op_script(data)
            expected = kornia.hsv_to_rgb(data)
            assert_allclose(actual, expected)
